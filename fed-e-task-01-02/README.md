## 一。请说出下列最终的执行结果，并解释为什么

``` javascript
    var a = [];
    for (var i = 0; i < 10; i++) {
        a[i] = function () {
            console.log(i)
        }
    }
    a[6]()
```

> 输出结果10。
> for 循环时是使用 var 定义循环变量 i ，存在变量提升，然后依次为 a 数组元素赋值为一个函数，函数内打印 i；循环结束后调用

## 二。请说出下列最终的执行结果，并解释为什么

``` javascript
    var tmp = 123;
    if (true) {
        console.log(tmp)
        let tmp
    }
```
> 最终执行结果为：报出引用错误，在初始化之前不能访问 'tmp'。
> 原因是因为，块级作用域内使用了 let 关键字声明变量，就存在暂时性死区，在声明之前使用这些变量会报错。

## 三。结合ES6新语法，用最简单的方式找出数组中的最小值

``` javascript
    var arr = [12, 34, 32, 89, 4];
```
``` javascript
    Math.min(...arr)
```

## 四。请详细说明var,let,const三种声明变量的方式之间的具体差别

> **var**:
存在变量提升的情况，访问在后续定义的变量会返回 undefined，var声明的变量，属于全局作用域

> **let**:
let声明的变量只在块级作用域内有效，同个作用域里，使用let不能重复声明变量

> **const**:
使用const声明的常量不能被修改，使用const声明常量时要赋初始值，使用const声明一个引用类型数据的常量，可以在这个常量上 增/删/改 属性，但是不能直接修改这个常量的值（内存地址不能修改）

## 五。请说出下列最终的执行结果，并解释为什么 

``` javascript
    var a = 10;
    var obj = {
        a: 20,
        fn() {
            setTimeout(() => {
            console.log(this.a)
            })
        }
    }
    obj.fn()
```

> 最终执行结果为：打印出 20。
> setTimeout的回调是一个箭头函数，箭头函数不会改变this的指向。this始终指向沿着作用域往上找的第一个 function ，调用 obj.fn() , 此时fn内的this指向obj。

## 六。简述symbol类型的用途 
> 为对象创建独一无二的属性（key）值，可以模拟实现对象的私有成员，可以用作常量

## 七。说说什么是浅拷贝，什么是深拷贝
> 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。
而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

> 浅拷贝的方法：遍历对象属性赋值，Object.assign()，展开运算符...
> 深拷贝的方法：浅拷贝+递归，JSON.parse(JSON.stringify(obj))

## 八。请简述TS与JS之间的关系
> TypeScript 是 JavaScript 的一个超集（扩展集），就是在 JS 的基础上多出一些扩展特性，TS 最终会被编译为 JS 运行。

## 九。请谈谈你所认为的TS优缺点
> **优点：**
* 使用 TS 新特性开发项目，项目代码的健壮性增强，代码错误更早暴露。
* 编辑器支持情况良好，有很多智能提示，编码更准确，提升开发效率。
* 使用 TS 的强类型特性来开发项目，可以使得项目代码重构更牢靠，减少很多不必要的类型判断。
* TS 最终会被编译为 JS 运行，可以将 ES6+ 编译为ES5/ES3，兼容性好。
* TS 是渐进式的，完全可以使用 JS 编写代码，可以将新特性慢慢应用到项目中。

> **缺点：**
* 引入了很多概念和新语法，有一定学习成本，同时增加项目开发成本

## 十。描述引用计数的工作原理和优缺点

> **工作原理：**
设置对象的引用数，有一个引用计数器来维护这些引用数，引用关系改变时修改引用数。判断当前对象引用数是否为0，引用数为0时立即回收。

> **优点：**
* 发现垃圾时立即回收
* 最大限度减少程序暂停

> **缺点：**
* 无法回收循环引用的对象
* 时间开销大，资源消耗较大

## 十一。描述标记整理算法的工作流程

* 标记整理可以看做是标记清除的增强，也是分标记和清除两个阶段来完成
* 标记阶段：遍历所有对象找标记活动对象
* 清除阶段：先执行整理，移动对象的位置，然后遍历所有对象清除没有标记的对象
* 最后回收相应的空间

ps:减少碎片化空间,但是不会立即回收垃圾对象

## 十二。描述V8中新生代存储区垃圾回收的流程
> 
* 回收过程采用复制算法 + 标记整理
* 新生代内存区分为两个等大小空间 From 和 To
* 使用空间为 From，空闲空间为 To
* 活动对象存储在 From 空间，标记整理后将活动对象拷贝至 To
* 拷贝过程中可能出现晋升（晋升就是将新生代对象移动至老生代）。
* 一轮 GC 还存活的新生代需要晋升；To 空间使用率超过 25%，也要将活动对象移动至老生代。
* 最后将 From 与 To 交换空间完成内存释放

## 十三。描述增量标记算法在何时使用及工作原理
> 增量标记算法：将一整段的垃圾回收操作，拆分成多个小步，组合完成整个垃圾回收操作。当垃圾回收工作的时候，会阻塞JS程序执行，当我们需要优化垃圾回收的效率时，就可以使用增量标记算法。优点是让垃圾回收与程序执行可以交替完成，让时间消耗更合理，达到效率优化的好处。

**工作原理：**
* JS 程序执行的过程中，会伴随着垃圾回收的工作
* 当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，此时停下标记操作
* 然后让JS程序执行一会，之后，再让 GC 机制去做二步的标记操作，去标记那些间接可达的对象
* 重复以上两步，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
* 直到标记操作完成之后，最后执行垃圾回收
